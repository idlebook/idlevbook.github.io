I"b<p align="center">
<img src="https://img.halfrost.com/Blog/ArticleImage/103_0.png" />
</p>

<h2 id="一为什么需要消息认证码">一、为什么需要消息认证码？</h2>

<p>还是举一个银行汇钱的例子：A 向 B 汇钱 100 万元。如果攻击者从中攻击，篡改这条消息，就可能变成 A 向攻击者汇钱 1000 万元。这里针对汇款消息，需要注意两个问题：消息的 “完整性” 和 “认证” 。</p>

<p>消息的完整性，就叫消息的一致性，这个可以用上一篇文章中讲的消息指纹来判断，通过对比单向散列函数的 hash 值来判断这条消息的完整性，有没有被篡改。</p>

<p>消息的认证，指的是，消息是否来自正确的发送者。如果确认汇款请求确实来自 A，就相当于对消息进行了认证，代表消息没有被伪装。</p>

<p><strong>如果同时需要识别出篡改和伪装，即要确认消息的完整性，又要对消息进行认证，这种情况下就需要消息认证码</strong>。</p>

<h2 id="二什么是消息认证码">二、什么是消息认证码？</h2>

<p><strong>消息认证码</strong>(Message Authentication Code) 是一种确认完整性并进行认证的技术，简称 MAC。</p>

<p>使用消息认证码可以确认自己收到的消息是否就是发送者的本意，也就是说可以判断消息是否被篡改，是否有人伪装成发送者发送了这条消息。</p>

<blockquote>
  <p>消息认证码也是密码学家工具箱中的 6 大工具之一：对称密码、公钥密码、单向散列函数、消息认证码、数字签名和伪随机数生成器。</p>
</blockquote>

<p>消息认证码的输入包括任意长度的<strong>消息</strong>和一个发送者与接收者之间的<strong>共享密钥</strong>。输出固定长度的数据，输出的数据就是 MAC 值。</p>

<p align="center">
<img src="https://img.halfrost.com/Blog/ArticleImage/103_1.png" />
</p>

<p>消息认证码和单向散列函数的区别就在有没有这个<strong>共享密钥</strong>上了。所以消息认证码就是利用共享密钥进行认证的。消息认证码和单向散列函数的散列值一样，如果消息发生了 1 比特的变化，MAC 值也会发生变化。所以消息认证码正是用这个性质来进行完整性的。</p>

<p>所以消息认证码可以理解为<strong>消息认证码是一种与密钥相关联的单向散列函数</strong>。</p>

<h2 id="三消息认证码的使用步骤">三、消息认证码的使用步骤</h2>

<p>如果银行之间汇款采用消息认证码，流程会如下：</p>

<p align="center">
<img src="https://img.halfrost.com/Blog/ArticleImage/103_2_.png" />
</p>

<p>大体流程和验证单向散列函数基本一致，只不过消息认证码需要共享密钥来解出 MAC 值。</p>

<p>不过消息认证码的共享密钥存在密钥配送问题。密钥在配送中不能被窃听者窃取。解决密钥配送问题需要用到上上篇文章中讲的公钥密码、Diffie-Hellman 密钥交换等其他安全的方式配送密钥。</p>

<h2 id="四消息认证码使用现状">四、消息认证码使用现状</h2>

<ul>
  <li>
    <p>SWIFT（Society for Worldwide Interbank Financial Telecommunications—环球同业银行金融电讯协会) 是一个目的为国际银行间的交易保驾护航的协会。银行和银行间通过 SWIFT 来传递交易消息，SWIFT 会利用消息认证码校验消息的完整性和对消息的验证。消息认证码的共享密钥是由人进行配送的。</p>
  </li>
  <li>
    <p>IPsec 是对 IP 协议增加安全性的一种方式，在 IPsec 中，对消息的认证和完整性校验也是用消息认证码的方式。</p>
  </li>
  <li>
    <p>SSL/TLS 对通信内容的认证和完整性校验也用了消息认证码。</p>
  </li>
</ul>

<h2 id="五消息认证码的实现方式">五、消息认证码的实现方式</h2>

<p align="center">
<img src="https://img.halfrost.com/Blog/ArticleImage/103_6.png" />
</p>

<ul>
  <li>
    <p>使用 SHA-2 之类的单向散列函数可以实现消息认证码，例如 HMAC。</p>
  </li>
  <li>
    <p>使用 AES 之类的分组密码可以实现消息认证码。分组密码的密钥作为共享密钥，利用 CBC 模式将消息全部加密。由于消息认证码中不需要解密，所以可以只留下最后一个分组，其他分组全部丢弃。CBC 模式的最后一个分组会受到整个消息以及密钥的双重影响，所以它可以作为 MAC 值。AES-CMAC (RFC4493) 就是一种基于 AES 来实现的消息认证码。</p>
  </li>
  <li>
    <p>流密码</p>
  </li>
  <li>
    <p>公钥密码</p>
  </li>
</ul>

<p>2000 年以后，人们基于认证的研究更加进一步，产生了<strong>认证加密</strong> (AE：Authenticated Encryption，AEAD：Authenticated Encryption with Associated Data)。认证加密是一种将对称密码和消息认证相结合的技术，同时满足加密性，完整性和认证性三大功能。</p>

<p>认证加密有几种，这里举例：例如 Encrypt-then-MAC，先用对称密码将明文加密，然后计算密文的 MAC 值。Encrypt-and-MAC，将明文用对称密码加密，并对明文计算 MAC 值。MAC-then-Encrypt，先计算明文的 MAC 值，然后将明文和 MAC 值同时用对称密码加密。<strong>在 HTTPS 中，一般使用 MAC-then-Encrypt 这种模式进行处理</strong>。</p>

<p>GCM(Galois/Counter Mode)是一种认证加密方式。GCM 中使用 AES 等 128 位比特分组密码的 CTR 模式，并使用一个反复进行加法和乘法运算的散列函数来计算 MAC 值。CTR 模式加密与 MAC 值的计算使用的是相同密钥，所以密钥管理很方便。专门用于消息认证码的 GCM 成为 GMAC。<strong>GCM 和 CCM (CBC Counter Mode) 都是被推荐的认证加密方式</strong>。</p>

<blockquote>
  <p>ChaCha20-Poly1305 是谷歌发明的一种算法，使用 ChaCha20 流密码进行加密运算，使用 Poly1305 算法进行 MAC 运算。</p>
</blockquote>

<h2 id="六hmac-算法">六、HMAC 算法</h2>

<p>HMAC 是一种使用单向散列函数来构造消息认证码的方法，HMAC 中的 H 是 Hash 的意思。官方文档见 <a href="https://tools.ietf.org/html/rfc2104">RFC 2104</a></p>

<p>任何高强度的单向散列函数都可以被用于 HMAC 中，例如 SHA-1、SHA-224、SHA-256、SHA-384、SHA-512 所构造的 HMAC，分别称为 HMAC-SHA1、HMAC-SHA-224、HMAC-SHA-256、HMAC-SHA-384、HMAC-SHA-512。</p>

<p>HMAC 计算 MAC 值步骤如下：</p>

<p align="center">
<img src="https://img.halfrost.com/Blog/ArticleImage/103_3__.png" />
</p>

<h3 id="1-密钥填充">1. 密钥填充</h3>

<p>如果密钥比单向散列函数的分组长度要短，就需要在末尾填充 0，使最终长度和单向散列函数分组长度一样。</p>

<p>如果密钥比分组长度要长，则要用单向散列函数求出密钥的散列值，然后把这个散列值作为 HMAC 的密钥。</p>

<h3 id="2-密钥变换-i">2. 密钥变换 I</h3>

<p>将填充后的密钥和 ipad 的比特序列进行 XOR 计算。ipad 是 00110110 (16进制的 36)不断循环直到长度和分组长度一样长的比特序列。ipad 的 i 是 inner 内部的意思。</p>

<p>XOR 得到的最终结果是一个<strong>和单向散列函数的分组长度相同，且和密钥相关的比特序列</strong>。这个序列称为 ipadkey。</p>

<h3 id="3-与消息组合">3. 与消息组合</h3>

<p>把 ipadkey 附加在消息的开头。</p>

<h3 id="4-计算散列值">4. 计算散列值</h3>

<p>把第 3 步的结果输入单向散列函数，计算出散列值。</p>

<h3 id="5-密钥变换-ii">5. 密钥变换 II</h3>

<p>将填充后的密钥和 opad 的比特序列进行 XOR 计算。opad 是 01011100 (16进制的 5C)不断循环直到长度和分组长度一样长的比特序列。opad 的 o 是 outer 外部的意思。</p>

<p>XOR 得到的最终结果是一个<strong>和单向散列函数的分组长度相同，且和密钥相关的比特序列</strong>。这个序列称为 opadkey。</p>

<h3 id="6-与散列值组合">6. 与散列值组合</h3>

<p>把 opadkey 附加在散列值的开头。</p>

<h3 id="7-计算散列值">7. 计算散列值</h3>

<p>把第 6 步的结果输入单向散列函数，计算出散列值。这个散列值即为最终 MAC 值。</p>

<p>最终的 MAC 值一定是一个和输入消息以及密钥都相关的长度固定的比特序列。</p>

<p>HMAC 如果用伪代码表示：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="n">HMAC</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">opadkey</span> <span class="o">||</span> <span class="n">hash</span><span class="p">(</span><span class="n">ipadkey</span> <span class="o">||</span> <span class="n">message</span><span class="p">))</span>
	 <span class="o">=</span> <span class="n">hash</span><span class="p">(</span> <span class="p">(</span><span class="n">key</span> <span class="err">⊕</span> <span class="n">opad</span><span class="p">)</span> <span class="o">||</span> <span class="n">hash</span><span class="p">(</span> <span class="p">(</span><span class="n">key</span> <span class="err">⊕</span> <span class="n">ipad</span><span class="p">)</span> <span class="o">||</span> <span class="n">message</span><span class="p">)</span> <span class="p">)</span>

<span class="n">opadkey</span> <span class="o">=</span> <span class="n">key</span> <span class="err">⊕</span> <span class="n">opad</span>
<span class="n">ipadkey</span> <span class="o">=</span> <span class="n">key</span> <span class="err">⊕</span> <span class="n">ipad</span>

<span class="n">key</span> <span class="err">为密钥，</span><span class="n">message</span> <span class="err">为消息，</span><span class="n">hash</span> <span class="err">计算为</span> <span class="n">hash</span><span class="p">()</span><span class="err">，</span><span class="n">A</span> <span class="o">||</span> <span class="n">B</span> <span class="err">代表</span> <span class="n">A</span> <span class="err">放在</span> <span class="n">B</span> <span class="err">的前面</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>具体举一个 HMAC_MD5 的例子：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td class="rouge-code"><pre><span class="cm">/*
** Function: hmac_md5
*/</span>

<span class="kt">void</span> <span class="n">hmac_md5</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">text_len</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">key_len</span><span class="p">,</span> <span class="n">digest</span><span class="p">)</span>
<span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>  <span class="n">text</span><span class="p">;</span>                <span class="cm">/* pointer to data stream */</span>
<span class="kt">int</span>             <span class="n">text_len</span><span class="p">;</span>            <span class="cm">/* length of data stream */</span>
<span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span>  <span class="n">key</span><span class="p">;</span>                 <span class="cm">/* pointer to authentication key */</span>
<span class="kt">int</span>             <span class="n">key_len</span><span class="p">;</span>             <span class="cm">/* length of authentication key */</span>
<span class="n">caddr_t</span>         <span class="n">digest</span><span class="p">;</span>              <span class="cm">/* caller digest to be filled in */</span>

<span class="p">{</span>
        <span class="n">MD5_CTX</span> <span class="n">context</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">k_ipad</span><span class="p">[</span><span class="mi">65</span><span class="p">];</span>    <span class="cm">/* inner padding -
                                      * key XORd with ipad
                                      */</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">k_opad</span><span class="p">[</span><span class="mi">65</span><span class="p">];</span>    <span class="cm">/* outer padding -
                                      * key XORd with opad
                                      */</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">tk</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="cm">/* if key is longer than 64 bytes reset it to key=MD5(key) */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key_len</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>

                <span class="n">MD5_CTX</span>      <span class="n">tctx</span><span class="p">;</span>

                <span class="n">MD5Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tctx</span><span class="p">);</span>
                <span class="n">MD5Update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tctx</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">key_len</span><span class="p">);</span>
                <span class="n">MD5Final</span><span class="p">(</span><span class="n">tk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tctx</span><span class="p">);</span>

                <span class="n">key</span> <span class="o">=</span> <span class="n">tk</span><span class="p">;</span>
                <span class="n">key_len</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/*
         * the HMAC_MD5 transform looks like:
         *
         * MD5(K XOR opad, MD5(K XOR ipad, text))
         *
         * where K is an n byte key
         * ipad is the byte 0x36 repeated 64 times
         * opad is the byte 0x5c repeated 64 times
         * and text is the data being protected
         */</span>

        <span class="cm">/* start out by storing key in pads */</span>
        <span class="n">bzero</span><span class="p">(</span> <span class="n">k_ipad</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">k_ipad</span><span class="p">);</span>
        <span class="n">bzero</span><span class="p">(</span> <span class="n">k_opad</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">k_opad</span><span class="p">);</span>
        <span class="n">bcopy</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">k_ipad</span><span class="p">,</span> <span class="n">key_len</span><span class="p">);</span>
        <span class="n">bcopy</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">k_opad</span><span class="p">,</span> <span class="n">key_len</span><span class="p">);</span>

        <span class="cm">/* XOR key with ipad and opad values */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">64</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">k_ipad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="mh">0x36</span><span class="p">;</span>
                <span class="n">k_opad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^=</span> <span class="mh">0x5c</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/*
         * perform inner MD5
         */</span>
        <span class="n">MD5Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>                   <span class="cm">/* init context for 1st
                                              * pass */</span>
        <span class="n">MD5Update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">k_ipad</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>      <span class="cm">/* start with inner pad */</span>
        <span class="n">MD5Update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">text_len</span><span class="p">);</span> <span class="cm">/* then text of datagram */</span>
        <span class="n">MD5Final</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>          <span class="cm">/* finish up 1st pass */</span>
        <span class="cm">/*
         * perform outer MD5
         */</span>
        <span class="n">MD5Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>                   <span class="cm">/* init context for 2nd
                                              * pass */</span>
        <span class="n">MD5Update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">k_opad</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>     <span class="cm">/* start with outer pad */</span>
        <span class="n">MD5Update</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> <span class="n">digest</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>     <span class="cm">/* then results of 1st
                                              * hash */</span>
        <span class="n">MD5Final</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>          <span class="cm">/* finish up 2nd pass */</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p>输出</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>  <span class="n">key</span> <span class="o">=</span>         <span class="mh">0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b</span>
  <span class="n">key_len</span> <span class="o">=</span>     <span class="mi">16</span> <span class="n">bytes</span>
  <span class="n">data</span> <span class="o">=</span>        <span class="s">"Hi There"</span>
  <span class="n">data_len</span> <span class="o">=</span>    <span class="mi">8</span>  <span class="n">bytes</span>
  <span class="n">digest</span> <span class="o">=</span>      <span class="mh">0x9294727a3638bb1c13f48ef8158bfc9d</span>
  
  
  <span class="n">key</span> <span class="o">=</span>         <span class="s">"Jefe"</span>
  <span class="n">data</span> <span class="o">=</span>        <span class="s">"what do ya want for nothing?"</span>
  <span class="n">data_len</span> <span class="o">=</span>    <span class="mi">28</span> <span class="n">bytes</span>
  <span class="n">digest</span> <span class="o">=</span>      <span class="mh">0x750c783e6ab0b503eaa86e310a5db738</span>
  
  
  <span class="n">key</span> <span class="o">=</span>         <span class="mh">0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span>
  <span class="n">key_len</span>       <span class="mi">16</span> <span class="n">bytes</span>
  <span class="n">data</span> <span class="o">=</span>        <span class="mh">0xDDDDDDDDDDDDDDDDDDDD</span><span class="p">...</span>
                <span class="p">..</span><span class="n">DDDDDDDDDDDDDDDDDDDD</span><span class="p">...</span>
                <span class="p">..</span><span class="n">DDDDDDDDDDDDDDDDDDDD</span><span class="p">...</span>
                <span class="p">..</span><span class="n">DDDDDDDDDDDDDDDDDDDD</span><span class="p">...</span>
                <span class="p">..</span><span class="n">DDDDDDDDDDDDDDDDDDDD</span>
  <span class="n">data_len</span> <span class="o">=</span>    <span class="mi">50</span> <span class="n">bytes</span>
  <span class="n">digest</span> <span class="o">=</span>      <span class="mh">0x56be34521d144c88dbb8c733f0e8b3f6</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="七对消息认证码的攻击">七、对消息认证码的攻击</h2>

<p align="center">
<img src="https://img.halfrost.com/Blog/ArticleImage/103_5.png" />
</p>

<h3 id="1-重放攻击">1. 重放攻击</h3>

<p align="center">
<img src="https://img.halfrost.com/Blog/ArticleImage/103_4_.png" />
</p>

<p>窃听者不直接破解消息认证码，而是把它保存起来，反复利用，这种攻击就叫做<strong>重放攻击(replay attack)</strong>。</p>

<p>防止重放攻击可以有 3 种方法：</p>

<ul>
  <li>
    <p>序号<br />
每条消息都增加一个递增的序号，并且在计算 MAC 值的时候把序号也包含在消息中。这样攻击者如果不破解消息认证码就无法计算出正确的 MAC 值。这个方法的弊端是每条消息都需要多记录最后一个消息的序号。</p>
  </li>
  <li>
    <p>时间戳<br />
发送消息的时候包含当前时间，如果收到的时间与当前的不符，即便 MAC 值正确也认为是错误消息直接丢弃。这样也可以防御重放攻击。这个方法的弊端是，发送方和接收方的时钟必须一致，考虑到消息的延迟，所以需要在时间上留下一定的缓冲余地。这个缓冲之间还是会造成重放攻击的可趁之机。</p>
  </li>
  <li>
    <p>nonce<br />
在通信之前，接收者先向发送者发送一个一次性的随机数 nonce。发送者在消息中包含这个 nonce 并计算 MAC 值。由于每次 nonce 都会变化，因此无法进行重放攻击。这个方法的缺点会导致通信的数据量增加。</p>
  </li>
</ul>

<h3 id="2-密钥推测攻击">2. 密钥推测攻击</h3>

<p>消息认证码同样可以暴力破解以及生日攻击。消息认证码必须要保证不能通过 MAC 值推测出通信双方所使用的密钥。这一点可以通过单向散列函数的单向性和抗碰撞性来保证无法推测出密钥。</p>

<h2 id="八消息认证码无法解决的问题">八、消息认证码无法解决的问题</h2>

<p>消息认证码虽然可以证明双方发送的消息是一致的，没有篡改，也不存在中间人伪装。但是它无法 “对第三方证明” 和 “防止抵赖”。</p>

<p>无法 “对第三方证明” 原因是因为消息认证码中用到的密钥是共享密钥，通信双方都有这个密钥，所以对第三方无法证明消息到底出自双方中的哪一方。<br />
解决 “第三方证明” 的问题需要用到数字签名。</p>

<p>无法 “防止抵赖” 原因是也是因为消息认证码的共享密钥双方都有，无法判断消息是发自于哪一方。所以消息认证码无法防止否认(nonrepudiation)。<br />
解决 “防止抵赖” 的问题需要用到数字签名。</p>

<h2 id="九总结">九、总结</h2>

<p align="center">
<img src="https://img.halfrost.com/Blog/ArticleImage/102_2.png" />
</p>

<p>单向散列函数保证消息的一致性，完整性，没有被篡改。<br />
消息认证码保证消息的一致性，完整性，没有被篡改，并且不存在中间人伪装。<br />
数字签名保证消息的一致性，完整性，没有被篡改，并且不存在中间人伪装，并且能防止抵赖。</p>

<hr />

<p>Reference：</p>

<p>《图解密码技术》</p>

<blockquote>
  <p>GitHub Repo：<a href="HTTPS://github.com/halfrost/Halfrost-Field">Halfrost-Field</a></p>

  <p>Follow: <a href="HTTPS://github.com/halfrost">halfrost · GitHub</a></p>

  <p>Source: <a href="https://halfrost.com/message_authentication_code/">https://halfrost.com/message_authentication_code/</a></p>
</blockquote>
:ET