<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>关于 Backpressure 和 Combine 中的处理</title>
  <meta name="description" content="  本文是对我的《SwiftUI 和 Combine 编程》书籍的补充，对一些虽然很重要，但和书中上下文内容相去略远，或者一些不太适合以书本的篇幅详细展开解释的内容进行了追加说明。如果你对 SwiftUI 和 Combine 的更多话题有兴趣的话，可以考虑参阅原书。">
  <meta name="author" content="Wei Wang">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="关于 Backpressure 和 Combine 中的处理">
  <meta name="twitter:description" content="  本文是对我的《SwiftUI 和 Combine 编程》书籍的补充，对一些虽然很重要，但和书中上下文内容相去略远，或者一些不太适合以书本的篇幅详细展开解释的内容进行了追加说明。如果你对 SwiftUI 和 Combine 的更多话题有兴趣的话，可以考虑参阅原书。">
  
  <meta property="og:type" content="article">
  <meta property="og:title" content="关于 Backpressure 和 Combine 中的处理">
  <meta property="og:description" content="  本文是对我的《SwiftUI 和 Combine 编程》书籍的补充，对一些虽然很重要，但和书中上下文内容相去略远，或者一些不太适合以书本的篇幅详细展开解释的内容进行了追加说明。如果你对 SwiftUI 和 Combine 的更多话题有兴趣的话，可以考虑参阅原书。">
  
  <link rel="icon" type="image/png" href="/assets/images/favicon.png" />
  <link href="/assets/images/favicon.png" rel="shortcut icon" type="image/png">
  
  <link rel="stylesheet" href="/css/main.css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/2019/12/backpressure-in-combine/">
  <link rel="alternate" type="application/rss+xml" title="OneV's Den" href="http://localhost:4000/feed.xml">
  
  <meta name="google-site-verification" content="1-1ZlHoRvM0T2FqPbW2S-qLgYXN6rsn52kErlMPd_gw" />
  
</head>


  <body>

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    
    <header class="panel-cover panel-cover--collapsed" style="background-image: url('/assets/images/background-cover.jpg')">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/#blog" title="前往 OneV's Den 的主页" class="blog-button"><img src="/assets/images/avatar.jpg" width="80" alt="OneV's Den logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/#blog" title="link to homepage for OneV's Den" class="blog-button">OneV's Den</a></h1>

        
        <span class="panel-cover__subtitle panel-subtitle">上善若水，人淡如菊</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">嗨，我是王巍 (@onevcat)，一名 iOS 开发者。</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        
        
        <p class="panel-cover__description"><a href="https://objccn.io/products/">我组织的 ObjC 中国与 objc.io 合作发布了一系列 iOS/Swift 相关图书，欢迎访问了解更多</a></p>
        
        
        <div class="navigation-wrapper">
          <div>
            <nav class="cover-navigation cover-navigation--primary">
              <ul class="navigation">
                <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">博客</a></li>
                
                  <li class="navigation__item"><a href="//onev.cat" target="_blank" title="我的简历">简历</a></li>
                
                  <li class="navigation__item"><a href="/apps" target="_blank" title="我所使用的 app 们">工具</a></li>
                
              </ul>
            </nav>
          </div>
          
          <div><nav class="cover-navigation navigation--social">
  <ul class="navigation">

  
  <!-- Weibo -->
  <li class="navigation__item">
    <a href="http://weibo.com/onevcat" title="@onevcat 的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>
  

  
  <!-- Github -->
  <li class="navigation__item">
    <a href="https://github.com/onevcat" title="@onevcat 的 Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>
  
  
  
  <!-- Twitter -->
  <li class="navigation__item">
    <a href="http://twitter.com/onevcat" title="@onevcat" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>
  

  

  <!-- RSS -->
  <li class="navigation__item">
    <a href="/feed.xml" rel="author" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>

  
  <!-- Email -->
  <li class="navigation__item">
    <a href="mailto:onev@onevcat.com" title="Contact me">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>
  

  </ul>
</nav>
</div>
        </div>
      </div>
    </div>
    
    
    <div class="panel-cover--overlay cover-blue"></div>
    
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2019-12-01 11:32:00 +0800" itemprop="datePublished" class="post-meta__date date">2019-12-01</time> &#8226; <span class="post-meta__tags tags">能工巧匠集</span>
    </div>
    <h1 class="post-title">关于 Backpressure 和 Combine 中的处理</h1>
  </header>

  <section class="post">
    <blockquote>
  <p>本文是对我的《SwiftUI 和 Combine 编程》书籍的补充，对一些虽然很重要，但和书中上下文内容相去略远，或者一些不太适合以书本的篇幅详细展开解释的内容进行了追加说明。如果你对 SwiftUI 和 Combine 的更多话题有兴趣的话，可以考虑<a href="https://objccn.io/products/swift-ui">参阅原书</a>。</p>
</blockquote>

<p>Combine 在 API 设计上很多地方都参考了 Rx 系，特别是 <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> 的做法。如果你已经对响应式编程很了解的话，从 RxSwift 迁移到 Combine 应该是轻而易举的。如果要说起 RxSwift 和 Combine 的最显著的不同，那就是 RxSwift 在可预期的未来<a href="https://github.com/ReactiveX/RxSwift/issues/1666?source=post_page-----64780a150d89----------------------#issuecomment-395546338">没有支持 backpressure 的计划</a>；但是 Combine 中原生对这个特性进行了支持：在 Combine 中你可以在 <code class="highlighter-rouge">Subscriber</code> 中返回追加接收的事件数量，来定义 Backpressure 的响应行为。在这篇文章里，我们会解释这个行为。</p>

<h2 id="什么是-backpressure为什么需要处理它">什么是 Backpressure，为什么需要处理它</h2>

<p>虽然在 iOS 客户端中，backpressure 也许不是那么常见，但是这在软件开发里可能是一个开发者或多或少都会遇到的话题。Backpressure 这个词来源于流体力学，一般被叫做<strong>背压</strong>或者<strong>回压</strong>，指的是<strong>流体在管道中流动时，(由于高度差或者压力所产生的阻滞) 在逆流动方向上的阻力</strong>。在响应式的编程世界中，我们经常会把由 Publisher，Operator 和 Subscriber 组成的事件处理方式比喻为“管道”，把对应的不断发生的事件叫做“事件流”。类比而言，在这个上下文中，backpressure 指的是<strong>在事件流动中，下游 (Operator 或者 Subscriber) 对上游 Publisher 的阻力</strong>。</p>

<p>为什么会产生这样的“阻力”呢？一个最常见的原因就是下游的 Subscriber 的处理速度无法跟上上游 Publisher 产生事件的速度。在理想世界中，如果我们的处理速度无穷，那么不管 Publisher 以多快的速度产生事件，Subscriber 都可以消化并处理这些事件。但是实际情况显然不会如此，有时候 Publisher 的事件生成速度可以远超 Subscriber 的处理速度，这种情况下就会产生一些问题。</p>

<p>举例来说，比如我们的 Publisher 从一个快速的 web socket 接受数据，经过一系列类似 <a href="https://developer.apple.com/documentation/combine/publishers/map"><code class="highlighter-rouge">Publishers.Map</code></a> 的变形操作，将接收到的数据转换为 app 中的 Model，最终的订阅者在接收到数据后执行 UI 渲染的工作，把数据添加到 Table View 里并绘制 UI。很显然，相对于 UI 渲染来说，接收数据和数据变形是非常快的。在一帧 (60 Hz 下的话，16ms) 中，我们可以接收和处理成千上万条数据，但是可能只能创建和渲染十多个 cell。如果我们想要处理这些数据，朴素来说，可能的方式有四种：</p>

<ol>
  <li>阻塞主线程，在这一帧中处理完这成千上万的 cell。</li>
  <li>把接受到的数据暂存在一个 buffer 里，取出合适的量进行处理。剩余部分则等待下一帧或者稍后空闲时再进行渲染。</li>
  <li>在接收到数据后，使用采样方法丢弃掉一部分数据，只去处理部分数据，以满足满帧渲染。</li>
  <li>控制事件产生的速度，让事件的发生速度减慢，来“适应”订阅者处理的速度。</li>
</ol>

<p>在客户端开发中，方案 1 是最不可取的，很显然它会把 UI 整个卡死，甚至让我们可爱的 <a href="https://stackoverflow.com/a/36644249/1468886">watchdog 0x8badf00d (ate bad food)</a> 从而造成 app 崩溃。方案 2 在某些情况下可能会有用，但是如果数据一直堆积，buffer 迟早会发生溢出。对于方案 3，在“将大量数据渲染到 UI 上”这一情景中，UI 刷新的速率将远远超过人能看到和处理的信息量，所以它是可行的，丢弃掉部分数据并不会造成使用体验上的影响。方案 4 如果可以实现的话，则是相对理想的 backpressure 处理方式：让发送端去适配接收端，在保证体验的情况下同时也保障了数据完整性，并且 (至少对客户端来说) 不会存在 buffer 溢出的情况。</p>

<p>另外一个常见的例子是大型文件转存，例如从磁盘的某个位置通过一个 stream 读取数据，然后将它写入到另一个地方。磁盘的读写速度往往是存在差别的，通常来说读速要比写速快很多。假设磁盘读取速度为 100 MB/s，写入速度为 50 MB/s，如果两端都全速的话，每秒将会堆积 50 MB 的数据到 buffer 中，很多场景下这是难以接受的。我们可以通过限制读取速度，来完美解决这个速度差，而这就是上面的方案 4 中的思想。</p>

<p>简单来说，backpressure 提供了一种方案，来解决在异步操作中发送端和接收端速率无法匹配的问题 (通常是发送端快于接收端)。在一个 (像是 Combine 这样的) 异步处理框架中，是否能够支持控制上游速度来处理 backpressure，关键取决于一点：事件的发送到底是基于<strong>拉取模型</strong>还是<strong>推送模型</strong>。如果是拉取模型，那么所定义的 Publisher 会根据要求<strong>按需发送</strong>，那么我们就可以控制事件发送的频率，进而处理前述的上下游速度不匹配的问题。</p>

<h2 id="自定义-subscriber">自定义 Subscriber</h2>

<h3 id="combine-框架基于拉取的事件模型">Combine 框架基于拉取的事件模型</h3>

<p>好消息是，Combine 的事件发送确实是基于拉取模型的。我们回顾一下典型的 Combine 订阅和事件发送的流程：</p>

<p><img src="/assets/images/2019/publisher-subscriber-flow.svg" alt="" /></p>

<p>图中共有三种主要角色，除了两端的 <code class="highlighter-rouge">Publisher</code> 和 <code class="highlighter-rouge">Subscriber</code> 以外，还有一个负责作为“桥梁”连接两者的 <code class="highlighter-rouge">Subscription</code>。</p>

<p>步骤 3，4 和 5 中分别涉及到 <code class="highlighter-rouge">Subscription</code> 和 <code class="highlighter-rouge">Subscriber</code> 的下面两个方法：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">Subscription</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">request</span><span class="p">(</span><span class="n">_</span> <span class="nv">demand</span><span class="p">:</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Demand</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">protocol</span> <span class="kt">Subscriber</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">receive</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="k">Self</span><span class="o">.</span><span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Demand</span>
<span class="p">}</span>
</code></pre></div></div>

<p>它们都和 <code class="highlighter-rouge">Subscribers.Demand</code> 相关：这个值表示了 <code class="highlighter-rouge">Subscriber</code> 希望接收的事件数量。Combine 框架中有这样的约定：<code class="highlighter-rouge">Subscriber</code> 对应着的订阅所发出的事件总数，不应该超过 <code class="highlighter-rouge">Subscription.request(_:)</code> 所传入的 <code class="highlighter-rouge">Demand</code> 和接下来每次 <code class="highlighter-rouge">Subscriber.receive(_:)</code> 被调用时返回的 <code class="highlighter-rouge">Demand</code> 的值的累加。基于这个规则，<code class="highlighter-rouge">Subscriber</code> 可以根据自身情况通过使用合适的 <code class="highlighter-rouge">Demand</code> 来控制上游。</p>

<p>这么说会有些抽象。在这篇文章里，我们会把注意力集中在 <code class="highlighter-rouge">Subscriber</code> 上，首先来看看如何实现自定义的 <code class="highlighter-rouge">Subscriber</code>，由此理解 Combine 的拉取模型的意义。然后再尝试实现一个能够控制 <code class="highlighter-rouge">Publisher</code> 发送事件的特殊 <code class="highlighter-rouge">Subscriber</code>。</p>

<p>关于图中另外两种角色 <code class="highlighter-rouge">Publisher</code> 和 <code class="highlighter-rouge">Subscription</code>，我可能会在另外的文章里再进行更多说明。</p>

<h3 id="重写-sink">重写 Sink</h3>

<p>在订阅某个 <code class="highlighter-rouge">Publisher</code> 时，大概最常用的莫过于 <code class="highlighter-rouge">sink</code> 了：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">publisher</span><span class="o">.</span><span class="nf">sink</span><span class="p">(</span>
    <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Completion: </span><span class="se">\(</span><span class="n">completion</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Receive value: </span><span class="se">\(</span><span class="n">value</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>
</code></pre></div></div>

<p>定义在 <code class="highlighter-rouge">Publisher</code> 上的扩展方法 <code class="highlighter-rouge">sink(receiveCompletion:receiveValue:)</code> 只不过是标准的订阅流程的简写方式。按照“正规的”方式，我们可以明确地创建 <code class="highlighter-rouge">Subscriber</code> 并让它订阅 <code class="highlighter-rouge">Publisher</code>，上面的代码等效于：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">publisher</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">publisher</span>
<span class="k">let</span> <span class="nv">subscriber</span> <span class="o">=</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Sink</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Completion: </span><span class="se">\(</span><span class="n">completion</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Receive value: </span><span class="se">\(</span><span class="n">value</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="n">publisher</span><span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="n">subscriber</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Sink</code> 做的事情非常简单，它在订阅时直接申请接受 <code class="highlighter-rouge">Subscribers.Demand.unlimited</code> 个元素。在每次收到事件时，调用预先设定的 block。现在，作为起始，我们来创建一个自定义的 <code class="highlighter-rouge">MySink</code>：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1</span>
<span class="kd">extension</span> <span class="kt">Subscribers</span> <span class="p">{</span>
    <span class="c1">// 2</span>
    <span class="kd">class</span> <span class="kt">MySink</span><span class="o">&lt;</span><span class="kt">Input</span><span class="p">,</span> <span class="kt">Failure</span><span class="p">:</span> <span class="kt">Error</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">Subscriber</span><span class="p">,</span> <span class="kt">Cancellable</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">(</span><span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Completion</span><span class="o">&lt;</span><span class="kt">Failure</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span>
        <span class="k">let</span> <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">(</span><span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span>
        <span class="c1">// 3</span>
        <span class="k">var</span> <span class="nv">subscription</span><span class="p">:</span> <span class="kt">Subscription</span><span class="p">?</span>
        
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>Combine 中的 <code class="highlighter-rouge">Publisher</code> 和 <code class="highlighter-rouge">Subscriber</code> 大都作为内嵌类型，定义在 <code class="highlighter-rouge">Publishers</code> 和 <code class="highlighter-rouge">Subscribers</code> 中。在这里，我们也遵循这个规则，把 <code class="highlighter-rouge">MySink</code> 写在 <code class="highlighter-rouge">Subscribers</code> 里。</li>
  <li>我们想让 <code class="highlighter-rouge">MySink</code> 满足 <code class="highlighter-rouge">Cancellable</code>，因此需要持有 <code class="highlighter-rouge">subscription</code>，才能在未来取消这个订阅。在语义上来说，我们也不希望发生复制，所以使用 <code class="highlighter-rouge">class</code> 来声明 <code class="highlighter-rouge">MySink</code>。这也是实现自定义 <code class="highlighter-rouge">Subscriber</code> 的一般做法。</li>
  <li>在 <code class="highlighter-rouge">Subscriber</code> 中持有 <code class="highlighter-rouge">subscription</code> 是很常见的操作，除了用来对应取消以外，这还可以让我们灵活处理额外的值的请求，稍后我们会看到这方面的内容。</li>
</ol>

<p>接下来，创建一个初始化方法，它接受 <code class="highlighter-rouge">receiveCompletion</code> 和 <code class="highlighter-rouge">receiveValue</code>：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">init</span><span class="p">(</span>
    <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Completion</span><span class="o">&lt;</span><span class="kt">Failure</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">,</span>
    <span class="nv">receiveValue</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">receiveCompletion</span> <span class="o">=</span> <span class="n">receiveCompletion</span>
    <span class="k">self</span><span class="o">.</span><span class="n">receiveValue</span> <span class="o">=</span> <span class="n">receiveValue</span>
<span class="p">}</span>
</code></pre></div></div>

<p>想要实现 <code class="highlighter-rouge">Subscriber</code> 协议，我们需要实现协议中定义的所有三个方法：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Subscriber</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">receive</span><span class="p">(</span><span class="nv">subscription</span><span class="p">:</span> <span class="kt">Subscription</span><span class="p">)</span>
    <span class="kd">func</span> <span class="nf">receive</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="k">Self</span><span class="o">.</span><span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Demand</span>
    <span class="kd">func</span> <span class="nf">receive</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Completion</span><span class="o">&lt;</span><span class="k">Self</span><span class="o">.</span><span class="kt">Failure</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">MySink</code> 里，我们可以完全遵循 <code class="highlighter-rouge">Sink</code> 的做法：在一开始收到订阅时，就请求无限多的事件；而在后续收到值时，则不再做 (也不需要做) 更多的请求：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">receive</span><span class="p">(</span><span class="nv">subscription</span><span class="p">:</span> <span class="kt">Subscription</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">subscription</span> <span class="o">=</span> <span class="n">subscription</span>
    <span class="n">subscription</span><span class="o">.</span><span class="nf">request</span><span class="p">(</span><span class="o">.</span><span class="n">unlimited</span><span class="p">)</span>
<span class="p">}</span>
        
<span class="kd">func</span> <span class="nf">receive</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Demand</span> <span class="p">{</span>
    <span class="nf">receiveValue</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">.</span><span class="k">none</span>
<span class="p">}</span>
        
<span class="kd">func</span> <span class="nf">receive</span><span class="p">(</span><span class="nv">completion</span><span class="p">:</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Completion</span><span class="o">&lt;</span><span class="kt">Failure</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">receiveCompletion</span><span class="p">(</span><span class="n">completion</span><span class="p">)</span>
    <span class="n">subscription</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后，为了实现 <code class="highlighter-rouge">Cancellable</code>，我们需要将 <code class="highlighter-rouge">cancel()</code> 的调用“转发”给 <code class="highlighter-rouge">subscription</code>：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">cancel</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">subscription</span><span class="p">?</span><span class="o">.</span><span class="nf">cancel</span><span class="p">()</span>
    <span class="n">subscription</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>为了避免意外的循环引用 (因为 <code class="highlighter-rouge">Subscription</code> 很多情况下也会持有 <code class="highlighter-rouge">Subscriber</code>)，所以在收到完成事件或者收到取消请求时，不再继续需要订阅的情况下，要记得将 <code class="highlighter-rouge">subscription</code> 置回为 <code class="highlighter-rouge">nil</code>。</p>

<p>最后的最后，为了方便使用，不妨为 <code class="highlighter-rouge">Publisher</code> 提供一个扩展方法，来帮助我们用 <code class="highlighter-rouge">MySink</code> 做订阅：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Publisher</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">mySink</span><span class="p">(</span>
        <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Completion</span><span class="o">&lt;</span><span class="kt">Failure</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">,</span>
        <span class="nv">receiveValue</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Output</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Cancellable</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="nv">sink</span> <span class="o">=</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">MySink</span><span class="o">&lt;</span><span class="kt">Output</span><span class="p">,</span> <span class="kt">Failure</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="n">receiveCompletion</span><span class="p">,</span>
            <span class="nv">receiveValue</span><span class="p">:</span> <span class="n">receiveValue</span>
        <span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">subscribe</span><span class="p">(</span><span class="n">sink</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sink</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">publisher</span><span class="o">.</span><span class="nf">mySink</span><span class="p">(</span>
    <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Completion: </span><span class="se">\(</span><span class="n">completion</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Receive value: </span><span class="se">\(</span><span class="n">value</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="c1">// 输出：</span>
<span class="c1">// Receive value: 1</span>
<span class="c1">// Receive value: 2</span>
<span class="c1">// Receive value: 3</span>
<span class="c1">// Receive value: 4</span>
<span class="c1">// Receive value: 5</span>
<span class="c1">// Completion: finished</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">mySink</code> 的行为和原始的 <code class="highlighter-rouge">sink</code> 应该是完全一致的。现在我们就可以开始着手修改 <code class="highlighter-rouge">MySink</code> 的代码，让事情变得更有趣一些了。</p>

<h3 id="按照-demand-的需求来发送事件">按照 Demand 的需求来发送事件</h3>

<p>我们可以对 <code class="highlighter-rouge">MySink</code> 做一点手脚，来控制它的拉取行为。比如将 <code class="highlighter-rouge">receive(subscription:)</code> 里初始的请求数量调整为 <code class="highlighter-rouge">.max(1)</code>：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">receive</span><span class="p">(</span><span class="nv">subscription</span><span class="p">:</span> <span class="kt">Subscription</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">subscription</span> <span class="o">=</span> <span class="n">subscription</span>
    <span class="c1">// subscription.request(.unlimited)</span>
    <span class="n">subscription</span><span class="o">.</span><span class="nf">request</span><span class="p">(</span><span class="o">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样一来，输出就停留在只有一行了：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Receive value: 1
</code></pre></div></div>

<p>这是因为现在我们只在订阅发生时去请求了一个值，而在 <code class="highlighter-rouge">receive(_:)</code> 里，我们返回的 <code class="highlighter-rouge">.none</code> 代表不再需要 <code class="highlighter-rouge">Publisher</code> 给出新值了。在这个方法中，我们有机会决定下一次的事件请求数量：可以将请求数从 <code class="highlighter-rouge">.none</code> 调整为 <code class="highlighter-rouge">.max(1)</code>：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">receive</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Demand</span> <span class="p">{</span>
    <span class="nf">receiveValue</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
    <span class="c1">// return .none</span>
    <span class="k">return</span> <span class="o">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>输出将恢复原来的情况：每当 <code class="highlighter-rouge">MySink</code> 收到一个值时，它会再去<strong>拉取</strong>下一个值，直到最后结束。我们可以通过为 <code class="highlighter-rouge">Publisher</code> 添加 <code class="highlighter-rouge">print()</code> 来从控制台输出确定这个行为：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// [1,2,3,4,5].publisher</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">publisher</span><span class="o">.</span><span class="nf">print</span><span class="p">()</span>
    <span class="o">.</span><span class="nf">mySink</span><span class="p">(</span>
        <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Completion: </span><span class="se">\(</span><span class="n">completion</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">},</span>
        <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
            <span class="c1">// print("Receive value: \(value)")</span>
        <span class="p">}</span>
    <span class="p">)</span>

<span class="c1">// 输出：</span>
<span class="c1">// receive subscription: ([1, 2, 3, 4, 5])</span>
<span class="c1">// request max: (1)</span>
<span class="c1">// receive value: (1)</span>
<span class="c1">// request max: (1) (synchronous)</span>
<span class="c1">// receive value: (2)</span>
<span class="c1">// request max: (1) (synchronous)</span>
<span class="c1">// receive value: (3)</span>
<span class="c1">// ... </span>
</code></pre></div></div>

<p>通过在 <code class="highlighter-rouge">Subscriber</code> 里的 <code class="highlighter-rouge">receive(subscription:)</code> 和 <code class="highlighter-rouge">receive(_:)</code> 来控制 <code class="highlighter-rouge">Subscribers.Demand</code>，我们做到了控制 <code class="highlighter-rouge">Publisher</code> 的事件发送。那要如何使用这个特性处理 backpressure 的情况呢？</p>

<h2 id="能够处理-backpressure-的-subscriber">能够处理 backpressure 的 Subscriber</h2>

<h3 id="让已停止的事件流继续">让已停止的事件流继续</h3>

<p>按照 Combine 约定，当 <code class="highlighter-rouge">Publisher</code> 发送的值满足 <code class="highlighter-rouge">Subscriber</code> 所要求的数量后，便不再发送新的值。在上面的 <code class="highlighter-rouge">MySink</code> 实现里，只要将 <code class="highlighter-rouge">receive(_:)</code> 的返回值设为 <code class="highlighter-rouge">.none</code>，那么就只会有第一个值被发出。这时候我们便遇到了一个问题，因为后续的值不会再被发送，<code class="highlighter-rouge">receive(_:)</code> 也不会再被调用，因此我们不再有机会在 <code class="highlighter-rouge">receive(_:)</code> 中返回新的 <code class="highlighter-rouge">Demand</code>，来让 <code class="highlighter-rouge">Publisher</code> 重新开始工作。</p>

<p>我们需要一种方式来“重新启动”这个流程，那就是 <code class="highlighter-rouge">Subscription</code> 上的 <code class="highlighter-rouge">request(_ demand: Subscribers.Demand)</code> 方法。在订阅刚开始时，我们已经使用过它来开始第一次发送。现在，当 <code class="highlighter-rouge">Publisher</code> “暂停”后，我也也可以从外部用它来重启发送流程，这也是我们要暂存 <code class="highlighter-rouge">subscription</code> 的另一个重要理由。</p>

<p>在 <code class="highlighter-rouge">MySink</code> 里添加 <code class="highlighter-rouge">resume</code> 方法：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">resume</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">subscription</span><span class="p">?</span><span class="o">.</span><span class="nf">request</span><span class="p">(</span><span class="o">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>创建一个 <code class="highlighter-rouge">Resumable</code> 协议，并让 <code class="highlighter-rouge">MySink</code> 遵守这个协议：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">Resumable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">resume</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Subscribers</span> <span class="p">{</span>
    <span class="kd">class</span> <span class="kt">MySink</span><span class="o">&lt;</span><span class="kt">Input</span><span class="p">,</span> <span class="kt">Failure</span><span class="p">:</span> <span class="kt">Error</span><span class="o">&gt;</span>
    <span class="p">:</span> <span class="kt">Subscriber</span><span class="p">,</span> <span class="kt">Cancellable</span><span class="p">,</span> <span class="kt">Resumable</span> 
    <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="c1">// MySink 已经实现了 resume()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后，把 <code class="highlighter-rouge">Publisher.mySink</code> 的返回类型从 <code class="highlighter-rouge">Cancellable</code> 修改为 <code class="highlighter-rouge">Cancellable &amp; Resumable</code> 的联合：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Publisher</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">mySink</span><span class="p">(</span>
        <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Completion</span><span class="o">&lt;</span><span class="kt">Failure</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">,</span>
        <span class="nv">receiveValue</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Output</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Cancellable</span> <span class="o">&amp;</span> <span class="kt">Resumable</span>
    <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在，即使我们把 <code class="highlighter-rouge">MySink</code> 里 <code class="highlighter-rouge">receive(_:)</code> 的返回值改回 <code class="highlighter-rouge">.none</code>，让 <code class="highlighter-rouge">Publisher</code> 在被订阅后只发出一次值，我们也可以再通过反复调用 <code class="highlighter-rouge">resume(_:)</code> 来“分批次”拉取所有值了：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Subscribers</span> <span class="p">{</span>
    <span class="kd">class</span> <span class="kt">MySink</span> <span class="c1">//... {</span>
        <span class="kd">func</span> <span class="nf">receive</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Demand</span> <span class="p">{</span>
            <span class="nf">receiveValue</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">.</span><span class="k">none</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">subscriber</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">publisher</span><span class="o">.</span><span class="nf">print</span><span class="p">()</span>
    <span class="o">.</span><span class="nf">mySink</span><span class="p">(</span>
        <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Completion: </span><span class="se">\(</span><span class="n">completion</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">},</span>
        <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
            <span class="nf">print</span><span class="p">(</span><span class="s">"Receive value: </span><span class="se">\(</span><span class="n">value</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">)</span>

<span class="n">subscriber</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
<span class="n">subscriber</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
<span class="n">subscriber</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
<span class="n">subscriber</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="注入控制逻辑暂停-publisher-发送">注入控制逻辑，暂停 <code class="highlighter-rouge">Publisher</code> 发送</h3>

<p>现在我们只差最后一块拼图了，那就是到底由谁来负责暂停 <code class="highlighter-rouge">Publisher</code> 的逻辑。当前的 <code class="highlighter-rouge">MySink</code> 中，由于开始订阅时只接受了 <code class="highlighter-rouge">.max(1)</code>，同时， <code class="highlighter-rouge">receive(_:)</code> 返回的是 <code class="highlighter-rouge">.none</code>，所以在接到第一个值后，<code class="highlighter-rouge">Publisher</code> 是无条件暂停的。实际上，和 <code class="highlighter-rouge">resume</code> 逻辑类似，我们会更希望将暂停的逻辑也“委托”出去，由调用者来决定合适的暂停时机：<code class="highlighter-rouge">receiveValue</code> 回调是一个不错的地方。将 <code class="highlighter-rouge">MySink</code> 中的 <code class="highlighter-rouge">receiveValue</code> 签名进行修改，让它返回一个 <code class="highlighter-rouge">Bool</code> 来表示是否应该继续下一次请求，并为 <code class="highlighter-rouge">MySink</code> 添加一个属性持有它：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">MySink</span> <span class="c1">// ... {</span>
    <span class="c1">// let receiveValue: (Input) -&gt; Void</span>
    <span class="k">let</span> <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">(</span><span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    
    <span class="k">var</span> <span class="nv">shouldPullNewValue</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span>
    
    <span class="nf">init</span><span class="p">(</span>
        <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Completion</span><span class="o">&lt;</span><span class="kt">Failure</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">,</span>
        <span class="c1">// receiveValue: @escaping (Input) -&gt; Void</span>
        <span class="nv">receiveValue</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="p">)</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Publisher</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">mySink</span><span class="p">(</span>
        <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Completion</span><span class="o">&lt;</span><span class="kt">Failure</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">,</span>
        <span class="c1">// receiveValue: @escaping (Output) -&gt; Void</span>
        <span class="nv">receiveValue</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Output</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Cancellable</span> <span class="o">&amp;</span> <span class="kt">Resumable</span>
</code></pre></div></div>

<p>当 <code class="highlighter-rouge">shouldPullNewValue</code> 为 <code class="highlighter-rouge">true</code> 时，在收到新值后，应当继续请求下一个值；否则，便不再继续请求，将事件流关闭，等待外界调用 <code class="highlighter-rouge">resume</code> 再重启。</p>

<p>对 <code class="highlighter-rouge">MySink</code> 的相关方法进行修改：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">receive</span><span class="p">(</span><span class="nv">subscription</span><span class="p">:</span> <span class="kt">Subscription</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">subscription</span> <span class="o">=</span> <span class="n">subscription</span>
    <span class="nf">resume</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">receive</span><span class="p">(</span><span class="n">_</span> <span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Demand</span> <span class="p">{</span>
    <span class="n">shouldPullNewValue</span> <span class="o">=</span> <span class="nf">receiveValue</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">shouldPullNewValue</span> <span class="p">?</span> <span class="o">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="o">.</span><span class="k">none</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">resume</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="o">!</span><span class="n">shouldPullNewValue</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="n">shouldPullNewValue</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="n">subscription</span><span class="p">?</span><span class="o">.</span><span class="nf">request</span><span class="p">(</span><span class="o">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样，就可以在使用的时候通过 <code class="highlighter-rouge">receiveValue</code> 闭包返回 <code class="highlighter-rouge">false</code> 来暂停；在暂停后，通过调用 <code class="highlighter-rouge">resume</code> 来继续了。</p>

<p>假设我们有一个巨大 (甚至无限！) 的数据集，在使用 <code class="highlighter-rouge">sink</code> 的情况下由于处理速度无法跟上事件的发送速度，我们将会被直接卡死：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">1</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">publisher</span><span class="o">.</span><span class="nf">sink</span><span class="p">(</span>
    <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Completion: </span><span class="se">\(</span><span class="n">completion</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Receive value: </span><span class="se">\(</span><span class="n">value</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">)</span>
</code></pre></div></div>

<p>但是如果我们通过使用 <code class="highlighter-rouge">mySink</code> 并设定一定条件，就可以很优雅地处理这个 backpressure。比如每秒只需要 <code class="highlighter-rouge">Publisher</code> 发送五个事件，并进行处理：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">buffer</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]()</span>
<span class="k">let</span> <span class="nv">subscriber</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">publisher</span><span class="o">.</span><span class="nf">print</span><span class="p">()</span><span class="o">.</span><span class="nf">mySink</span><span class="p">(</span>
    <span class="nv">receiveCompletion</span><span class="p">:</span> <span class="p">{</span> <span class="n">completion</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Completion: </span><span class="se">\(</span><span class="n">completion</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="nv">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Receive value: </span><span class="se">\(</span><span class="n">value</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="n">buffer</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">buffer</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">5</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="k">let</span> <span class="nv">cancellable</span>  <span class="o">=</span> <span class="kt">Timer</span><span class="o">.</span><span class="nf">publish</span><span class="p">(</span><span class="nv">every</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">on</span><span class="p">:</span> <span class="o">.</span><span class="n">main</span><span class="p">,</span> <span class="nv">in</span><span class="p">:</span> <span class="o">.</span><span class="k">default</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">autoconnect</span><span class="p">()</span>
    <span class="o">.</span><span class="n">sink</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span>
        <span class="n">buffer</span><span class="o">.</span><span class="nf">removeAll</span><span class="p">()</span>
        <span class="n">subscriber</span><span class="o">.</span><span class="nf">resume</span><span class="p">()</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>通过这种方式，我们自定义的 <code class="highlighter-rouge">MySink</code> 成为了一个可以用于处理 backpressure 的通用方案。</p>

<blockquote>
  <p>相关的代码可以<a href="https://gist.github.com/onevcat/baecc584e3cbfa2cc161290b2dfd300a">在这里找到</a>。</p>
</blockquote>

<h2 id="练习">练习</h2>

<p>为了保持和<a href="(https://objccn.io/products/swift-ui)">《SwiftUI 和 Combine 编程》</a>这本书的形式上的类似，我也准备了一些小练习，希望能帮助读者通过实际动手练习掌握本文的内容。</p>

<h3 id="1-自定义实现-subscribersassign">1. 自定义实现 <code class="highlighter-rouge">Subscribers.Assign</code></h3>

<p>文中自定义了 <code class="highlighter-rouge">MySink</code>，来复现 <code class="highlighter-rouge">Sink</code> 的功能。现在请你依照类似的方式创建一个你自己的 <code class="highlighter-rouge">MyAssign</code> 类型，让它和 <code class="highlighter-rouge">Subscribers.Assign</code> 的行为一致。作为提示，下面是 Combine 框架中 <code class="highlighter-rouge">Subscribers.Assign</code> 的 (简化版的) public 声明：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Assign</span><span class="o">&lt;</span><span class="kt">Root</span><span class="p">,</span> <span class="kt">Input</span><span class="o">&gt;</span> <span class="p">:</span> <span class="kt">Subscriber</span><span class="p">,</span> <span class="kt">Cancellable</span> <span class="p">{</span>
    <span class="kd">typealias</span> <span class="kt">Failure</span> <span class="o">=</span> <span class="kt">Never</span>
    <span class="k">var</span> <span class="nv">object</span><span class="p">:</span> <span class="kt">Root</span><span class="p">?</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
    <span class="k">let</span> <span class="nv">keyPath</span><span class="p">:</span> <span class="kt">ReferenceWritableKeyPath</span><span class="o">&lt;</span><span class="kt">Root</span><span class="p">,</span> <span class="kt">Input</span><span class="o">&gt;</span>
    
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2-一次-request-超过-max1-个数的事件">2. 一次 request 超过 <code class="highlighter-rouge">.max(1)</code> 个数的事件</h3>

<p>在引入 <code class="highlighter-rouge">resume</code> 时，我们将 <code class="highlighter-rouge">.max(1)</code> 硬编码在了方法内部：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">resume</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">subscription</span><span class="p">?</span><span class="o">.</span><span class="nf">request</span><span class="p">(</span><span class="o">.</span><span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们能不能修改这个方法的签名，让它更灵活一些，接受一个 <code class="highlighter-rouge">Demand</code> 参数，让它可以向 <code class="highlighter-rouge">subscription</code> 请求多个值？比如：</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">resume</span><span class="p">(</span><span class="n">_</span> <span class="nv">demand</span><span class="p">:</span> <span class="kt">Subscribers</span><span class="o">.</span><span class="kt">Demand</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">subscription</span><span class="p">?</span><span class="o">.</span><span class="nf">request</span><span class="p">(</span><span class="n">demand</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这么做会对 <code class="highlighter-rouge">Resumable</code> 产生影响吗？会对之后我们想要实现的暂停逻辑有什么影响？我们还能够使用这样的 <code class="highlighter-rouge">resume</code> 写出可靠的暂停和重启逻辑么？</p>

<h3 id="3-通用的-subscriber-和专用的-subscriber">3. 通用的 Subscriber 和专用的 Subscriber</h3>

<p>本文最后我们实现的是一个相对通用的 Subscriber，但是如果逻辑更复杂，或者需要大规模重复使用时，把逻辑放在 <code class="highlighter-rouge">receiveValue</code> 闭包中会有些麻烦。</p>

<p>请尝试把原文中 「<code class="highlighter-rouge">buffer</code> 元素数到达 5 时，暂停一秒」这个逻辑封装起来，用一个新的专用的 <code class="highlighter-rouge">Subscriber</code> 替代。你可以尝试两个方向：</p>

<ol>
  <li>使用一个新的类型，包装现有的 <code class="highlighter-rouge">MySink</code>，将判断逻辑放到新类型中；<code class="highlighter-rouge">Subscriber</code> 协调所需要定义的方法，通过转发的方式交给 <code class="highlighter-rouge">MySink</code> 处理。</li>
  <li>完全重新实现一个和 <code class="highlighter-rouge">MySink</code> 无关的 <code class="highlighter-rouge">Subscriber</code>，专门用来处理这类定时开关的事件流。</li>
</ol>

  </section>
</article>

<section class="read-more">
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">最近的文章</span>
       <h2 class="post-list post-list__post-title post-title"><a href="/2019/12/2019-final/" title="link to 2019 年终总结">2019 年终总结</a></h2>
       <p class="excerpt">距离上一次写年终总结已经过去四年时间了。在人生中带上两个小朋友以后，远游这种事情的难度就高企不下了。一年里除了工作以外，活动的轨迹多半也都落在了以家为圆心两公里为半径的圆周里。看着小朋友们一天天长大，在被她们的想象力和好奇心折服的同时，也不可避免地感觉到了自己的“成熟”…嗯，或者直白些，不可避免地感觉到了自己在变老。对我来说，2019 年是很有意思的一年，它是充满“矛盾”的一年。我能认知的世界在变大，但我实际生活的圈子却在变小。世界的变动非常剧烈，在中美争霸背景下，被时代洪流的裹挟向前的我...&hellip;</p>
       <div class="post-list__meta"><time datetime="2019-12-31 13:22:00 +0800" class="post-list__meta--date date">2019-12-31</time> &#8226; <span class="post-list__meta--tags tags">胡言乱语集</span><a class="btn-border-small" href=/2019/12/2019-final/>继续阅读</a></div>
   </div>
   
   
   
   
   <div class="read-more-item">
       <span class="read-more-item-dim">更早的文章</span>
       <h2 class="post-list post-list__post-title post-title"><a href="/2019/06/swift-ui-firstlook-2/" title="link to SwiftUI 的一些初步探索 (二)">SwiftUI 的一些初步探索 (二)</a></h2>
       <p class="excerpt">  我已经计划写一本关于 SwiftUI 和 Combine 编程的书籍，希望能通过一些实践案例帮助您快速上手 SwiftUI 及 Combine 响应式编程框架，掌握下一代客户端 UI 开发技术。现在这本书已经开始预售，预计能在 10 月左右完成。如果您对此有兴趣，可以查看 ObjC 中国的产品页面了解详情及购买。十分感谢！接上一篇继续对 SwiftUI 的教程进行一些解读。教程 2 - Building Lists and NavigationSection 4 - Step 2: 静...&hellip;</p>
       <div class="post-list__meta"><time datetime="2019-06-11 11:32:00 +0800" class="post-list__meta--date date">2019-06-11</time> &#8226; <span class="post-list__meta--tags tags">能工巧匠集</span><a class="btn-border-small" href=/2019/06/swift-ui-firstlook-2/>继续阅读</a></div>
   </div>
   
</section>



            <section class="footer">
    <footer>
    	<span class="footer__copyright">本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a></span>
        <span class="footer__copyright">由 <a href="https://jekyllrb.com">Jekyll</a> 于 2020-05-14 生成</span>
        <span class="footer__copyright">本站由 <a href="https://onev.cat">@onevcat</a> 创建，采用 <a href="https://github.com/onevcat/vno-jekyll">Vno - Jekyll</a> 作为主题，您可以在 GitHub 找到<a href="https://github.com/onevcat/OneV-s-Den">本站源码</a> - &copy; 2020</span>
    </footer>
</section>

        </div>
    </div>
    
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.3.min.js"></script>



<script type="text/javascript" src="/js/main.js"></script>


<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-25719337-1', 'onevcat.com');
    ga('send', 'pageview');
</script>


    
  </body>

</html>
